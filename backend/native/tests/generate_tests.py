# Python RNG
import random

random.seed(42)

# Numpy RNG
import numpy as np

np.random.seed(42)

# TF RNG
from tensorflow.python.framework import random_seed

random_seed.set_seed(42)

import tensorflow.keras.layers as tf_layers
from jinja2 import Template

import sys

rng = np.random.default_rng()

array_template = Template("float {{name}}[] = { {{content}} };")
parameter_template = Template("int {{name}} = {{value}};")
ret_template = Template("float ret[{{size}}];")
testing_template = Template("""
//This file was generated by backend/native/generate_tests.py

#include "gmock/gmock.h"
#include "nn.h"
 
using namespace testing;
using namespace eNNclave;
 
{% for test in tests %}
TEST({{test.suite}}, {{test.name}}){
    {% for declaration in test.declarations %}
    {{declaration}}{% endfor %}
        
    {{test.operator}}
    ASSERT_THAT(ret, Pointwise(FloatNear(1e-5), expected));
} 
{% endfor %}
 """)


def generate_array(name, a):
    content = ''
    array = a.flatten()
    for i in range(array.shape[0]):
        content += f'{array[i]}'
        if i < array.shape[0] - 1:
            content += ','
    return array_template.render(name=name, content=content)


def generate_dense(test_name='small', h=5, w=5, neurons=5, mode='full'):
    declarations = [parameter_template.render(name='h', value=h),
                    parameter_template.render(name='w', value=w),
                    parameter_template.render(name='neurons', value=neurons)]

    inputs = np.random.rand(1, h, w)
    declarations.append(generate_array('inputs', inputs))

    if mode == 'zeros':
        layer = tf_layers.Dense(neurons, kernel_initializer='zeros', input_shape=inputs.shape)
    elif mode == 'full':
        layer = tf_layers.Dense(neurons, bias_initializer='glorot_uniform', input_shape=inputs.shape)
    elif mode == 'identity':
        layer = tf_layers.Dense(neurons, kernel_initializer='identity', input_shape=inputs.shape)
    else:
        raise NotImplementedError("Unknown test mode")

    results = layer(inputs).numpy()
    params = layer.get_weights()
    declarations.append(generate_array('weights', params[0]))
    declarations.append(generate_array('biases', params[1]))
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=h * neurons))

    operator = "dense(inputs, h, w, weights, neurons, biases, ret);"

    return {'suite': 'dense', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_sep_conv1(test_name="small", steps=3, channels=3, filters=3, kernel_size=2, mode='full'):
    declarations = [parameter_template.render(name='steps', value=steps),
                    parameter_template.render(name='channels', value=channels),
                    parameter_template.render(name='filters', value=filters),
                    parameter_template.render(name='kernel_size', value=kernel_size)]

    inputs = np.random.rand(1, steps, channels)
    declarations.append(generate_array('inputs', inputs))

    if mode == 'zeros':
        layer = tf_layers.SeparableConv1D(
            filters, kernel_size, strides=1, input_shape=inputs.shape, padding='same', use_bias=True,
            bias_initializer='zeros', depthwise_initializer='zeros', pointwise_initializer='zeros')
    elif mode == 'full':
        layer = tf_layers.SeparableConv1D(
            filters, kernel_size, strides=1, input_shape=inputs.shape, padding='same', use_bias=True,
            bias_initializer='glorot_uniform', depthwise_initializer='glorot_uniform',
            pointwise_initializer='glorot_uniform')
    else:
        raise NotImplementedError("Unknown tests mode")

    results = layer(inputs).numpy()
    params = layer.get_weights()
    depth_kernels = params[0]
    declarations.append(generate_array('depth_kernels', depth_kernels))
    point_kernels = params[1]
    declarations.append(generate_array('point_kernels', point_kernels))
    biases = params[2]
    declarations.append(generate_array('biases', biases))
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=steps * filters))

    operator = "sep_conv1(inputs, steps, channels, filters, depth_kernels, point_kernels, kernel_size, biases, ret);"

    return {'suite': 'sep_conv1', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_conv2(test_name='small', h=3, w=3, channels=3, filters=3, kernel_size=3, mode='full'):
    declarations = [parameter_template.render(name='h', value=h),
                    parameter_template.render(name='w', value=w),
                    parameter_template.render(name='channels', value=channels),
                    parameter_template.render(name='filters', value=filters),
                    parameter_template.render(name='kernel_size', value=kernel_size)]

    inputs = np.random.rand(1, h, w, channels)

    if mode == 'zeros':
        layer = tf_layers.Conv2D(
            filters, kernel_size, strides=1, input_shape=inputs.shape, padding='same', use_bias=True,
            bias_initializer='zeros', kernel_initializer='zeros')
    elif mode == 'sequential':
        inputs = np.arange(
            h * w * channels, dtype=np.float).reshape((1, h, w, channels))
        layer = tf_layers.Conv2D(filters, kernel_size, strides=1, input_shape=inputs.shape,
                                 padding='same', use_bias=True, bias_initializer='zeros',
                                 kernel_initializer='ones')
    elif mode == 'full':
        layer = tf_layers.Conv2D(
            filters, kernel_size, strides=1, input_shape=inputs.shape, padding='same', use_bias=True,
            bias_initializer='glorot_uniform', kernel_initializer='glorot_uniform')
    else:
        raise NotImplementedError("Unknown test mode")
    declarations.append(generate_array('inputs', inputs))

    results = layer(inputs).numpy()
    params = layer.get_weights()
    kernels = params[0]
    declarations.append(generate_array('kernels', kernels))
    biases = params[1]
    declarations.append(generate_array('biases', biases))
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=h * w * filters))

    operator = "conv2(inputs, h, w, channels, filters, kernels, kernel_size, kernel_size, biases, ret);"

    return {'suite': 'conv2', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_depthwise_conv2(test_name='small', h=3, w=3, channels=3, kernel_size=3, mode='full'):
    declarations = [parameter_template.render(name='h', value=h),
                    parameter_template.render(name='w', value=w),
                    parameter_template.render(name='channels', value=channels),
                    parameter_template.render(name='kernel_size', value=kernel_size)]

    inputs = np.random.rand(1, h, w, channels)

    if mode == 'zeros':
        layer = tf_layers.DepthwiseConv2D(kernel_size, padding='same', use_bias=False, bias_initializer='zeros',
                                          kernel_initializer='zeros')
    elif mode == 'sequential':
        inputs = np.arange(
            h * w * channels, dtype=np.float).reshape((1, h, w, channels))
        layer = tf_layers.DepthwiseConv2D(kernel_size, padding='same', use_bias=False, bias_initializer='zeros',
                                          kernel_initializer='ones')
    elif mode == 'full':
        layer = tf_layers.DepthwiseConv2D(kernel_size, padding='same', use_bias=False,
                                          bias_initializer='glorot_uniform', kernel_initializer='glorot_uniform')
    else:
        print("Unknown tests mode")
        sys.exit(1)

    declarations.append(generate_array('inputs', inputs))

    results = layer(inputs).numpy()
    params = layer.get_weights()
    kernels = params[0]
    declarations.append(generate_array('kernels', kernels))
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=h * w * channels))

    operator = "depthwise_conv2(inputs, h, w, channels, Padding::SAME, kernels, kernel_size, kernel_size, ret);"

    return {'suite': 'depthwise_conv2', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_relu(test_name='small', size=10):
    declarations = [parameter_template.render(name='size', value=size)]

    inputs = np.random.rand(1, size)
    declarations.append(generate_array('inputs', inputs))

    layer = tf_layers.ReLU(input_shape=inputs)
    results = layer(inputs).numpy()
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=size))

    operator = 'relu(inputs, size, ret);'

    return {'suite': 'relu', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_global_average_pooling_1d(test_name='small', steps=10, channels=3):
    declarations = [parameter_template.render(name='steps', value=steps),
                    parameter_template.render(name='channels', value=channels)]

    inputs = rng.uniform(-1, 1, (1, steps, channels))
    declarations.append(generate_array('inputs', inputs))

    layer = tf_layers.GlobalAveragePooling1D(
        input_shape=(steps, channels))

    results = layer(inputs).numpy()
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=channels))

    operator = 'global_average_pooling_1d(inputs, steps, channels, ret);'

    return {'suite': 'global_average_pooling1', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_global_average_pooling_2d(test_name='small', h=5, w=5, channels=3):
    declarations = [parameter_template.render(name='h', value=h),
                    parameter_template.render(name='w', value=w),
                    parameter_template.render(name='channels', value=channels)]
    inputs = rng.uniform(-1, 1, (1, h, w, channels))
    declarations.append(generate_array('inputs', inputs))

    layer = tf_layers.GlobalAveragePooling2D(
        input_shape=(h, w, channels))

    results = layer(inputs).numpy()
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=channels))

    operator = 'global_average_pooling_2d(inputs, h, w, channels, ret);'

    return {'suite': 'global_average_pooling2', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_max_pooling1d(test_name='small', steps=10, channels=3, pool_size=3, mode='random'):
    declarations = [parameter_template.render(name='steps', value=steps),
                    parameter_template.render(name='channels', value=channels),
                    parameter_template.render(name='pool_size', value=pool_size)]

    if mode == 'random':
        inputs = rng.uniform(-1, 1, (1, steps, channels))
    elif mode == 'sequential':
        inputs = np.arange(
            steps * channels).reshape((1, steps, channels)).astype(np.float)
    else:
        raise NotImplementedError(f"Unknown tests mode {mode}")

    declarations.append(generate_array('inputs', inputs))

    layer = tf_layers.MaxPooling1D(
        input_shape=inputs.shape, pool_size=pool_size, padding='valid')

    results = layer(inputs).numpy()
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=np.prod(results.shape)))

    operator = 'max_pooling_1d(inputs, steps, channels, pool_size, ret);'

    return {'suite': 'max_pooling1', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_max_pooling2d(test_name='small', h=5, w=5, channels=3, pool_size=3, mode='random'):
    declarations = [parameter_template.render(name='h', value=h),
                    parameter_template.render(name='w', value=w),
                    parameter_template.render(name='channels', value=channels),
                    parameter_template.render(name='pool_size', value=pool_size)]

    if mode == 'random':
        inputs = rng.uniform(-1, 1, (1, h, w, channels))
    elif mode == 'sequential':
        inputs = np.arange(
            h * w * channels, dtype=np.float).reshape((1, h, w, channels))
    else:
        print(f"Unknown tests mode {mode}")
        sys.exit(1)

    declarations.append(generate_array('inputs', inputs))

    layer = tf_layers.MaxPooling2D(
        input_shape=inputs.shape, pool_size=pool_size, padding='valid')

    results = layer(inputs).numpy()
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=np.prod(results.shape)))

    operator = 'max_pooling_2d(inputs, h, w, channels, pool_size, ret);'

    return {'suite': 'max_pooling2', 'name': test_name, 'declarations': declarations, 'operator': operator}


def generate_zero_pad2(test_name='small', h=3, w=3, channels=3, top_pad=1, bottom_pad=1, left_pad=1, right_pad=1):
    declarations = [parameter_template.render(name='h', value=h),
                    parameter_template.render(name='w', value=w),
                    parameter_template.render(name='channels', value=channels),
                    parameter_template.render(name='top_pad', value=top_pad),
                    parameter_template.render(name='bottom_pad', value=bottom_pad),
                    parameter_template.render(name='left_pad', value=left_pad),
                    parameter_template.render(name='right_pad', value=right_pad)]

    inputs = rng.uniform(-1, 1, (1, h, w, channels))
    declarations.append(generate_array('inputs', inputs))

    layer = tf_layers.ZeroPadding2D(input_shape=inputs.shape, padding=(
        (top_pad, bottom_pad), (left_pad, right_pad)))

    results = layer(inputs).numpy()
    declarations.append(generate_array('expected', results))
    declarations.append(ret_template.render(size=np.prod(results.shape)))

    operator = 'zero_pad2(inputs, h, w, channels, top_pad, bottom_pad, left_pad, right_pad, ret);'

    return {'suite': 'zero_pad2', 'name': test_name, 'declarations': declarations, 'operator': operator}


if __name__ == "__main__":
    tests = [
        generate_dense('zeros', 10, 10, 10, mode='zeros'),
        generate_dense('identity', 10, 10, 10, mode='identity'),
        generate_dense('small', 5, 5, 5),
        generate_dense('medium', 20, 20, 20),
        generate_dense('large', 50, 50, 50),

        generate_sep_conv1('zeros', 10, 10, 10, mode='zeros'),
        generate_sep_conv1('small', 5, 5, 5, 2),
        generate_sep_conv1('medium', 20, 20, 20, 3),
        generate_sep_conv1('large', 50, 50, 50, 5),

        generate_conv2('zeros', 10, 10, 10, mode='zeros'),
        generate_conv2('sequential', 10, 10, 10, mode='sequential'),
        generate_conv2('small', 5, 5, 5, 3, 3),
        generate_conv2('medium', 10, 10, 10, 3, 3),
        generate_conv2('large', 50, 50, 50, 10, 5),

        generate_depthwise_conv2('zeros', 10, 10, 10, mode='zeros'),
        generate_depthwise_conv2('sequential', 10, 10, 10, mode='sequential'),
        generate_depthwise_conv2('small', 5, 5, 5, 3),
        generate_depthwise_conv2('medium', 10, 10, 10, 3),
        generate_depthwise_conv2('large', 50, 50, 50, 5),

        generate_relu('small', 10),
        generate_relu('medium', 20),
        generate_relu('large', 50),

        generate_global_average_pooling_1d('small', 10, 3),
        generate_global_average_pooling_1d('medium', 20, 3),
        generate_global_average_pooling_1d('large', 50, 10),

        generate_global_average_pooling_2d('small', 5, 5, 3),
        generate_global_average_pooling_2d('medium', 20, 20, 5),
        generate_global_average_pooling_2d('large', 50, 50, 10),

        generate_max_pooling1d('sequential', 10, 5, 3, mode='sequential'),
        generate_max_pooling1d('small', 10, 3, 3),
        generate_max_pooling1d('medium', 20, 5, 3),
        generate_max_pooling1d('large', 50, 10, 5),

        generate_max_pooling2d('sequential', 10, 10, 3, 3, mode='sequential'),
        generate_max_pooling2d('small', 5, 5, 3, 3),
        generate_max_pooling2d('medium', 20, 20, 5, 3),
        generate_max_pooling2d('large', 50, 50, 10, 5),

        generate_zero_pad2()
    ]

    with open("core_tests.cpp", 'w') as test_file:
        test_code = testing_template.render(tests=tests)
        test_file.write(test_code)
        test_file.flush()
