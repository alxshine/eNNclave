* NN SGX
Running some parts or all of a CNN inside the trusted enclave to reduce leakage and protect against model stealing.
We hope to make this as robust against model stealing as online oracles.

** People
RBO, CPA, ASC

** Datasets
Currently only image recognition tasks are used for testing.
The tasks are MNIST using a small CNN, and MIT67 using a pretrained VGG16 network as feature extractor.
The VGG16 model has its weights fixed during retraining.
All datasets are stored in ~data~.

I am in the process of "onboarding" text recognition tasks, namely IMDB review sentiment classification using MLPs, and Rotten Tomatoes review sentiment classification using CNNs on sequences.
The code for these is taken from [[https://github.com/google/eng-edu/tree/master/ml/guides/text_classification][here]].

This gives us classification using CNNs on two different media types.

** Current Status
As of now moving large models (VGG16) into the enclave works correctly, but with massive slowdown.
Some results:
#+BEGIN_SRC text
Taking 10 images from MIT67 test_set
Predicting with TF model
Prediction took 0.582809 seconds
TF model accuracy: 0.6
Predicting with Enclave model
Prediction took 972.469672 seconds
10 of 10 labels are equal, slowdown factor: 1668.591
#+END_SRC
And for MNIST:
#+BEGIN_SRC text
Taking 100 images from MNIST test_set
Predicting with TF model
Prediction took 0.059973 seconds
TF model accuracy: 0.9
Predicting with Enclave model
Prediction took 3.748415 seconds
100 of 100 labels are equal, slowdown factor: 62.502
#+END_SRC

The slowdown is incurred due to the ineficcient way memory is accessed during convolution, and also because memory has to be paged constantly.

** Timing measurements
All code is compiled for SGX in HW_PRERERELEASE mode

*** Rotten Tomatoes
The times are averaged over 50 batches.
Enclave setup is not included in the times.
The first run is discarded to also filter out TF-GPU setup time.

A summary of the model is as follows:
#+BEGIN_SRC text
embedding:               	(None, 49, 200)
dropout:                 	(None, 49, 200)
separable_conv1d:        	(None, 49, 64)
separable_conv1d_1:      	(None, 49, 64)
max_pooling1d:           	(None, 16, 64)
separable_conv1d_2:      	(None, 16, 128)
separable_conv1d_3:      	(None, 16, 128)
global_average_pooling1d:	(None, 128)
dropout_1:               	(None, 128)
dense:                   	(None, 5)
#+END_SRC

The column specifies the number of layers *from the back* that are put in the enclave.

**** Tensorflow-GPU Times

#+PLOT: ind:1 deps:(2 3 4 5 6 7 8 9)
|-----------------+----------+----------+----------+----------+----------+----------+----------+----------|
| #(Batch)\Layers |        1 |        2 |        3 |        4 |        5 |        6 |        7 |        8 |
|-----------------+----------+----------+----------+----------+----------+----------+----------+----------|
|               1 | 0.021391 | 0.021506 | 0.021263 | 0.021504 | 0.021386 | 0.022156 | 0.022420 | 0.021786 |
|               5 | 0.021275 | 0.021364 | 0.021191 | 0.022280 | 0.021514 | 0.022063 | 0.020909 | 0.021172 |
|              10 | 0.021836 | 0.021329 | 0.021640 | 0.021221 | 0.021072 | 0.021168 | 0.021441 | 0.021476 |
|              50 | 0.010124 | 0.028781 | 0.030833 | 0.026013 | 0.025481 | 0.025112 | 0.024917 | 0.025178 |
|             100 | 0.043587 | 0.044060 | 0.045346 | 0.031918 | 0.031637 | 0.031476 | 0.031207 | 0.031222 |
|             500 | 0.110506 | 0.107064 | 0.101755 | 0.066747 | 0.069347 | 0.069550 | 0.068083 | 0.071315 |
|            1000 | 0.188149 | 0.199242 | 0.205119 | 0.153562 | 0.148908 | 0.150407 | 0.140155 | 0.138775 |
|            5000 | 1.206407 | 1.155464 | 1.180732 | 1.104479 | 1.016594 | 1.103854 | 1.065218 | 0.997463 |
|            7500 | 1.739533 | 1.722203 | 1.664009 | 1.713971 | 1.647305 | 1.559547 | 1.509747 | 1.509626 |
|           10000 | 2.001191 | 2.371181 | 2.288010 | 2.167776 | 2.171341 | 2.158835 | 2.139454 | 2.277547 |
|-----------------+----------+----------+----------+----------+----------+----------+----------+----------|

**** Enclave Times

#+PLOT: ind:1 deps:(2 3 4 5 6 7 8 9)
|-----------------+----------+----------+----------+-----------+-----------+-----------+-----------+------------|
| #(Batch)\Layers |        1 |        2 |        3 |         4 |         5 |         6 |         7 |          8 |
|-----------------+----------+----------+----------+-----------+-----------+-----------+-----------+------------|
|               1 | 0.004030 | 0.004101 | 0.003948 |  0.007372 |  0.008193 |  0.008101 |  0.010586 |   0.017241 |
|               5 | 0.004136 | 0.004141 | 0.004123 |  0.021474 |  0.025296 |  0.025948 |  0.035261 |   0.066643 |
|              10 | 0.004520 | 0.004509 | 0.004479 |  0.036173 |  0.045170 |  0.045452 |  0.065724 |   0.128432 |
|              50 | 0.032096 | 0.009325 | 0.010035 |  0.164765 |  0.208798 |  0.208383 |  0.307739 |   0.627604 |
|             100 | 0.018667 | 0.018899 | 0.021223 |  0.329236 |  0.415729 |  0.415255 |  0.614807 |   1.247830 |
|             500 | 0.158167 | 0.139720 | 0.154573 |  1.600334 |  2.074725 |  2.083692 |  3.058047 |   6.303066 |
|            1000 | 0.336998 | 0.339511 | 0.370344 |  3.205655 |  4.156700 |  4.118088 |  6.186466 |  12.533901 |
|            5000 | 1.822304 | 1.638312 | 1.880398 | 15.906983 | 20.669846 | 20.409218 | 30.551559 |  62.745630 |
|            7500 | 2.547575 | 2.434002 | 2.648802 | 23.779323 | 30.571529 | 30.915689 | 46.082133 |  93.974223 |
|           10000 | 2.731499 | 3.396491 | 3.452197 | 31.899413 | 41.893637 | 41.231440 | 61.369204 | 124.449159 |
|-----------------+----------+----------+----------+-----------+-----------+-----------+-----------+------------|


*** MIT67
The times are averaged over 50 batches.
Enclave setup is not included in the times.
The first run is discarded to also filter out TF-GPU setup time.

A summary of the model is as follows:
#+BEGIN_SRC text
input_1:                 	[(None, 224, 224, 3)]
block1_conv1:            	(None, 224, 224, 64)
block1_conv2:            	(None, 224, 224, 64)
block1_pool:             	(None, 112, 112, 64)
block2_conv1:            	(None, 112, 112, 128)
block2_conv2:            	(None, 112, 112, 128)
block2_pool:             	(None, 56, 56, 128)
block3_conv1:            	(None, 56, 56, 256)
block3_conv2:            	(None, 56, 56, 256)
block3_conv3:            	(None, 56, 56, 256)
block3_pool:             	(None, 28, 28, 256)
block4_conv1:            	(None, 28, 28, 512)
block4_conv2:            	(None, 28, 28, 512)
block4_conv3:            	(None, 28, 28, 512)
block4_pool:             	(None, 14, 14, 512)
block5_conv1:            	(None, 14, 14, 512)
block5_conv2:            	(None, 14, 14, 512)
block5_conv3:            	(None, 14, 14, 512)
block5_pool:             	(None, 7, 7, 512)
global_average_pooling2d:	(None, 512)
dense:                   	(None, 2048)
dropout:                 	(None, 2048)
dense_1:                 	(None, 2048)
dropout_1:               	(None, 2048)
dense_2:                 	(None, 67)
#+END_SRC

**** Tensorflow-GPU Times
|-----------------+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----------|
| #(Batch)\Layers | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 |       25 |
|-----------------+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----------|
|               1 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 0.028796 |
|               3 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 0.038081 |
|               5 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 0.055922 |
|               7 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 0.068730 |
|               8 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 0.074985 |
|               9 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 0.076803 |
|              10 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 0.079242 |
|              15 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 0.098056 |
|-----------------+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----------|

**** Enclave Times
The output of the first run was the following:
#+BEGIN_SRC text
BATCH SIZE:	1
NUM BATCHES:	10
SKIPPING FIRST 1 RESULTS

Tensorflow times:
[0.02612829 0.02624774 0.02640581 0.02641249 0.02847791 0.02616763
 0.02720594 0.0321269  0.03499079 0.03379607]
Mean:	0.028796
Min:	0.026128
Max:	0.034991

Enclave times:
[96.11019945 96.03487802 96.06326938 96.08898449 96.09725094 96.05501556
 96.0578084  96.07562447 96.07399631 96.05862665]
Mean:	96.071565
Min:	96.034878
Max:	96.110199

Enclave is slower than TF by a factor of 3336.286531
#+END_SRC

The difference between the minimum and maximum time for enclave execution is ~0.0784%~ of the total execution time.
I decided to reduce the number of time measurements to average to 5, because that reduces the time for each run, and with this low variance is still accurate enough.

The time for 25 layers and 1 image per batch is averaged over 10 runs, the rest is averaged over 5 runs


#+PLOT: ind:1 deps:(26)
|-----------------+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+-------------|
| #(Batch)\Layers | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 |          25 |
|-----------------+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+-------------|
|               1 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |   96.071565 |
|               3 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  288.826607 |
|               5 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  482.205610 |
|               7 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  669.602621 |
|               8 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  764.924860 |
|               9 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  860.603075 |
|              10 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    |  959.033667 |
|              15 |   |   |   |   |   |   |   |   |   |    |    |    |    |    |    |    |    |    |    |    |    |    |    | 1457.326541 |
|-----------------+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+-------------|
** Related Work
We have different areas of related work that are relevant to this project.
The most directly relevant area is model stealing attacks and adversarial robustness.
In model stealing an attacker tries to build a replicant model that rivals the prediction accuracy of the stolen model, with hopefully lower cost than using the original model.
[[file:related_work/tramer16stealing.pdf][Tramer et al.]] use a model-dependent dataset augmentation algorithm to find a reasonably low number of queries required for extracting the model.
The number they arrive at for NNs is ~100*k~, where ~k~ is the number of parameters.
Our model (even with the weights in the feature extractor fixed) still have ~18,000,000 trainable parameters, which pushes this attack (as it is) outside the realm of feasability in my opinion.

Another relevant area of research is adversarial attacks.
[[file:related_work/papernot17practical.pdf][Papernot et al.]] have presented a so-called black-box transfer attack, in which an attacker builds a local replicant model and builds adversarial examples on the gradients of that model.
This requires far less queries than are required for model stealing, but the replicant model does not have to be accurace.
Its only requirement is that its gradients are sufficiently aligned with the target model to build functional adversarial examples.

Our implementation affects data privacy, as it allows users to keep the data they wish to predict on private.
It also allows for the creation of offline black box oracles, which are used e.g. in [[file:related_work/shokri17membership.pdf][set membership attacks]].
As it currently stands, we do not return confidence values, only the resulting label.
This makes the attack presented by Shokri et al. not better than chance, as evidenced by their own results.

In the context of data privacy [[file:related_work/ohrimenko16enclave.pdf][Ohrimenko et al.]] have also previously combined machine learning with trusted enclaves.
The difference between their approach and ours is that they trained the model inside the enclave, which allows parties to also keep their training data private.
Their focus is on ensuring that no inference on the training data can be made using timing side channels, and they disregard performance.
Our focus is instead on the performance impact of such an approach.

[[file:related_work/tramer19slalom.pdf][Tramer et al.]] provide a mechanism to use the enclave as a controller for running NNs on the GPU.
Every layer is verified inside the Enclave, to give a statistical guarantee for integrity.
They also utilize an additive stream cipher which is (as they claim, I don't know enough of the math behind it to verify) invariant to the computations taking place in the DNN.
This gives them data privacy, while running the model on the provider's hardware.

The enclave alone does not provide a mechanism for rate limiting, and thus not for monetization.
[[file:related_work/kaptchuk2019state.pdf][Kaptchuk et al.]] utilize signatures coming from a server for this.
Their main contribution is putting the signatures in a public ledger, which might be sexy, but not necessary for our use-case.
The basic idea is very relevant however.
By having a customer send a hash of the data they wish to run inference on to the provider, who then signs the hash (after being paid) and sends the signature back, we can monetize access to the model by query.
The model can then verify the signature using the public testing key of the provider.
Only if the signature is valid will it run inference.
* README

** Setting up a testing environment
Building SGX enclaves on Linux requires building the SGX-SDK from scratch.
This process only works on Ubuntu 18.04 and some other older distributions.
Our test machines run Ubuntu Server 18.04, and I provide a setup script for the SDK [[file:setup/setup_sgx_machine.sh][here]].

The python requirements are all in [[file:requirements.txt][requirements.txt]].

** Training a model
Our current evaluation dataset, MIT67, can be downloaded [[http://web.mit.edu/torralba/www/indoor.html][here]].
The site provides a download of the dataset, as well as a specification of which images are in the training and test sets.
The specification files are great for having consistent and reproducible results.

Our training scripts expect the extracted data to be in ~data/mit67~, with both ~.txt~ files being in that directory as well.
The model can then be trained using the ~mit67_train.py~ script.

** Extracting the enclave
The script called ~build_enclave_files.py~ is used to generate the weight files and the C functions.
It takes two parameters: the original model file, and the number of layers to extract into an enclave.
The extracted layers will be replaced by an ~EnclaveLayer~, which wraps the generated enclave in a manner compatible with the TensorFlow API.
From the original layers that were not extracted and the new ~EnclaveLayer~ it builds a new model, and saves it.

The script creates a ~forward.cpp~ and multiple ~.bin~ files.
Inside the ~.bin~ files are the layer weights which will be compiled into the enclave.
The ~forward.cpp~ file contains the forward function of the enclave.

** Compiling the enclave
Building the enclave (or native) code happens in the ~lib~ directory, so move the generated files there.

The decision which version to build is decided based on the ~MODE~ environment variable.
All directories contain Makefiles, so running ~make~ in the project root will build all necessary subdirectories.

** Running the enclave
*** Setting up ~LD_LIBRARY_PATH~
The enclave model needs to be able to find the shared libraries that were previously compiled.
To provide the location of the libraries, please run this command from the project root:
#+BEGIN_SRC bash
source setup/setup_ld_path.sh
#+END_SRC

*** Evaluating models
TODO

** Under the hood
The underlying interaction with the enclave is a bit roundabout, but that also preserves modularity.

The ~EnclaveLayer~ calls the Python-C interoperability code in [[file:interop/pymatutilmodule.c][pymatutilmodule.c]] (which is previosly compiled into a shared library).
That code does the conversion between Python ~byte~ arrays and C ~char~ arrays.
It then calls the libraries generated in the ~lib~ directory, and converts the output back to Python objects.

The enclave also consists of two shared libraries, one in the enclave and one being the wrapper around the enclave that's autogenerated by the Intel SDK.

The rest is "basic" C interaction.
